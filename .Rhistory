seq_along(my_seq)
rep(0, times=40)
rep(c(0,1,2),times=10)
rep(c(0,1,2),each=10)
num_vect<-c(0.5,55,-10,6)
tf<-num_vect<1
tf
num_vect>=6
my_char<-c("My","name","is")
my_char
past(my_char,collapse = " ")
paste(my_char,collapse = " ")
my_name=c(my_char, "Aaron")
my name
my_name
paste(my_name,collapse=" ")
paste("Hello", "world!", sep= " ")
paste(1:3, c("X","Y","Z"), sep="")
paste (LETTERS, 1:4, sep="-")
x<-c(44,NA,5,NA)
x*3
y<-rnorm(1000)
z<-rep(NA,1000)
my_data<-sample(c(y,z),100)
my_na<-is.na(my_data)
my_na
my_data == NA
sum(my_na)
my_data
0/0
Inf-Inf
x
x[1:10]
x[is.na(x)]
y<-x[is.na(x)]
y<-x[!is.na(x)]
y
y[y>0]
x[x>0]
x[!is.na(x) & x > 0]
x[3,5,7]
?c
c(3:3,5:5,7:7]
ed
d
d
c(x[3:3],x[5:5],x[7:7])
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect <-c(foo=11,bar=2,norf=NA)
vect
names(vect)
vect2<-c(11,2,NA)
names(vect2) <- c("foo","bar","norf")
identical(vect,vect2)
vect("bar")
vect["bar"]
vect[c("foo","bar")]
q()
x
y
z
clear
cls
swirl()
library(swirl)
type ls()
ls()
rm(list=ls())
swirl()
my_vector<-1:20
x
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector)<-c(4,5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix<-my_vector
?matrix
my_matrix2<-matrix(1:20,nrow=4,ncol=5)
identical(my_matrix,my_matrix2)
patients<-c("Bill","Gina","Kelly","Sean")
cbind(patients,my_matrix)
my_data<-data.frame(patients,my_matrix)
my_data
class(my_frame)
calss(my_data_
)
class(my_data)
cnames<-c("patient", "age", "weight", "bp", "rating", "test")
colnames(my_data)<-cnames
my_data
quit()
add2 <- function(x,y) {
x + Y
}
add2(1,2)
add2()
add2<-function(x,y){
x+y
}
add2(1,1)
search()
}
above10<-function(x){
use<-x>10
x[use]
}
above<-function(x){
use<-x>10
x[use]
}
above10<-function(x){
above10<-function(x){
use<-x>10
x[use]
}
above<-function(x){
use<-x>10
x[use]
}
library()
library(swirl)
rm(list=ls())
swirl()
Sys.Date()
mean(c(2,4,5))
submit()
boring_function('My first function!')
boring_function
submit
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11.5)
remainder(11,5)
remainder(divisor=11,num=5)
remainder(4,div=2)
args(remainder)
submit()
evaluate(std,c(1.4,3.6,7.9,8.8))
help.search("std")
evaluate(sd,c(1.4,3.6,7.9,8.8))
evaluate(function(x){x+1},6)
evaluate{function(x){x[1]},c(8,4,0))
evaluate(function(x){x[1],c(8,4,0))
evaluate(function(x){x[1]},c(8,4,0))
evaluate(function(x){x[lenghth(x)]},c(8,4,0))
evaluate(function(x){x[length(x)]},c(8,4,0))
?paste
paste("Programming","is",'fun!")
;
jrwe
qwehr
8
9
paste("Programming", "is", "fun!")
quit()
paste("START ", ...)
simon_says <- function(...){
paste("Simon says:", ...)
}
telgram <- function(...){
paste("Simon says:", ...)
}
paste("START:", ...)
paste("Simon says:", ...)
simon_says <- function(...){
paste("Simon says:", ...)
}
telegram <- function(...){
paste("Simon says:", ...)
}
telgram(hello)
telegram("GOOD","DAY")
telegram <- function(...){
paste("START:", ...)
}
telegram <- function(...){
paste("START:", ...)
}
telegram <- function(...){
paste("START:", ...)
}
telegram("GOOD","DAY")
telegram("GOOD","DAY")
telegram("GOOD","DAY")
telegram <- function(...){
paste("START", ...)
}
telegram <- function(...){
;
/
telegram <- function(...){
paste("START", ...)
}
telegram("GOOD","DAY")
telegram <- function(...){
paste(paste("START", ...),"STOP")
}
telegram <- function(...){
paste(paste("START", ...),"STOP")
}
telgram("GOOD","DAY")
telegram("GOOD","DAY")
"%p%" <- function(left,right){ # Remember to add arguments!
paste(left,right)
}
"GOOD" %p% "job!"
"%p%" <- function(left,right){ # Remember to add arguments!
paste(left,right)
}
cube <- function(x, n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x <- 1
if(x > 5) {
x <- 0
}
x
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z<-10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
getwd()
x<-<c(1,2,3,4)
x<-c(1,2,3,4)
x<-as.matrix(x)
x
x<-C(1,2)
x<-c(1,2)
y<-x
?as.matrix
x<-c(1,2,3,4)
y<-as.matrix(x,nrow=2,ncol=2)
y
x
dim(y)
mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2"),
c("C.1", "C.2", "C.3")))
mdat
mdat <- matrix(c(1,2,3, 4), nrow = 2, ncol = 2, byrow = TRUE)
mdat
datm<-solve(mdat)
datm
mdat*datm
mdat%*%datm
mdat%*%solve(mdat)
mdat <- matrix(c(1,1,1, 1), nrow = 2, ncol = 2, byrow = TRUE)
mdat%*%solve(mdat)
mdat
mdat <- matrix(c(1,0,0, 1), nrow = 2, ncol = 2, byrow = TRUE)
solve(mdat)
mdat%*%solve(mdat)
mdat <- matrix(c(10,0,0, 10), nrow = 2, ncol = 2, byrow = TRUE)
solve(mdat)
mdat%*%solve(mdat)
mdat
mdat <- matrix(c(8,6,7,5), nrow = 2, ncol = 2, byrow = TRUE)
mdat%*%solve(mdat)
solve(mdat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(inv) i <<- inv
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
#put in more comments..
#m replaced by i
#mean replaced by inv
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
setwd("C:/Users/msaja/datasciencecoursera/ProgrammingAssignment2")
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                           #Assign null to i
set <- function(y) {
x <<- y                           #Assign y to x: note the << operator
i <<- NULL                        #Assign null to i: note the << operator
}
get <- function() x                 #Function Get x
setinv <- function(inv) i <<- inv   #Function set i to inv: note: inv is the function variable
getinv <- function() i              #Function Get i
list(set = set, get = get,          #Put all these function in a list
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
#put in more comments..
#m replaced by i
#mean replaced by inv
cacheSolve <- function(x, ...) {
i <- x$getinv()                      #Use getinv function to get inverse from the list
if(!is.null(i)) {                    #If inverse is not null return it
message("getting cached data")
return(i)                          #Return the value of i and exit the function
}
data <- x$get()                     #use get function pull matix off the list
i <- solve(data, ...)               #Calculate the inverse of data as assign to i
x$setinv(i)                         #Use setinv function to assign the inverse to the list
i                                   #return the inverse from the function
}
mdat <- matrix(c(8,6,7,5), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
x
x
cacheSolve(x)
cacheSolve(x)
cacheSolve(x)
mdat <- matrix(c(8,6,7,7), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
cacheSolve(x)
y<-cacheSolve(x)
x%*%y
mdat%*%y
mdat <- matrix(c(8,6,7,99), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
cacheSolve(x)
y<-cacheSolve(x)
mdat%*%y
## This code has 2 functions
## makeCacheMatrix which creates a special matrix object that can cache its inverse.
## cacheSolve which calculates the inverse of the special matrix.
## Details comments are provided in the function
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                           #Assign null to i
set <- function(y) {
x <<- y                           #Assign y to x: note the << operator
i <<- NULL                        #Assign null to i: note the << operator
}
get <- function() x                 #Function Get x
setinv <- function(inv) i <<- inv   #Function set i to inv: note: inv is the function variable
getinv <- function() i              #Function Get i
list(set = set, get = get,          #Put all these function in a list
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...) {
i <- x$getinv()                      #Use getinv function to get inverse from the list
if(!is.null(i)) {                    #If inverse is not null return it
message("getting cached data")
return(i)                          #Return the value of i and exit the function
}
data <- x$get()                     #use get function pull matix off the list
i <- solve(data, ...)               #Calculate the inverse of data as assign to i
x$setinv(i)                         #Use setinv function to assign the inverse to the list
i                                   #return the inverse from the function
}
mdat <- matrix(c(8,6,7,1000), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
cacheSolve(x)
y<-cacheSolve(x)
y<-cacheSolve(x)
mdat%*%y
mdat <- matrix(c(100,200,300,400), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
cacheSolve(x)
y<-cacheSolve(x)
mdat%*%y
## This code has 2 functions
## makeCacheMatrix which creates a special matrix object that can cache its inverse.
## cacheSolve which calculates the inverse of the special matrix.
## Detailed comments are provided in the functions
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                           #Assign null to i
set <- function(y) {
x <<- y                           #Assign y to x: note the << operator
i <<- NULL                        #Assign null to i: note the << operator
}
get <- function() x                 #Function Get x
setinv <- function(inv) i <<- inv   #Function set i to inv: note: inv is the function variable
getinv <- function() i              #Function Get i
list(set = set, get = get,          #Put all these function in a list
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...) {
i <- x$getinv()                      #Use getinv function to get inverse from the list
if(!is.null(i)) {                    #If inverse is not null return it
message("getting cached data")
return(i)                          #Return the value of i and exit the function
}
data <- x$get()                     #use get function pull matix off the list
i <- solve(data, ...)               #Calculate the inverse of data as assign to i
x$setinv(i)                         #Use setinv function to assign the inverse to the list
i                                   #return the inverse from the function
}
## This code has 2 functions
## makeCacheMatrix which creates a special matrix object that can cache its inverse.
## cacheSolve which calculates the inverse of the special matrix.
## Detailed comments are provided in the functions
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                           #Assign null to i
set <- function(y) {
x <<- y                           #Assign y to x: note the << operator
i <<- NULL                        #Assign null to i: note the << operator
}
get <- function() x                 #Function Get x
setinv <- function(inv) i <<- inv   #Function set i to inv: note: inv is the function variable
getinv <- function() i              #Function Get i
list(set = set, get = get,          #Put all these function in a list
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...) {
i <- x$getinv()                      #Use getinv function to get inverse from the list
if(!is.null(i)) {                    #If inverse is not null return it
message("getting cached data")
return(i)                          #Return the value of i and exit the function
}
data <- x$get()                     #use get function pull matix off the list
i <- solve(data, ...)               #Calculate the inverse of data as assign to i
x$setinv(i)                         #Use setinv function to assign the inverse to the list
i                                   #return the inverse from the function
}
mdat <- matrix(c(100,200,300,400), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
y<-cacheSolve(x)
mdat%*%y
## This code has 2 functions
## makeCacheMatrix which creates a special matrix object that can cache its inverse.
## cacheSolve which calculates the inverse of the special matrix.
## Detailed comments are provided in the functions
## At the bottom of the code is example commands to test the functions
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                           #Assign null to i
set <- function(y) {
x <<- y                           #Assign y to x: note the << operator
i <<- NULL                        #Assign null to i: note the << operator
}
get <- function() x                 #Function Get x
setinv <- function(inv) i <<- inv   #Function set i to inv: note: inv is the function variable
getinv <- function() i              #Function Get i
list(set = set, get = get,          #Put all these function in a list
setinv = setinv,
getinv = getinv)
}
cacheSolve <- function(x, ...) {
i <- x$getinv()                      #Use getinv function to get inverse from the list
if(!is.null(i)) {                    #If inverse is not null return it
message("getting cached data")
return(i)                          #Return the value of i and exit the function
}
data <- x$get()                     #use get function pull matix off the list
i <- solve(data, ...)               #Calculate the inverse of data as assign to i
x$setinv(i)                         #Use setinv function to assign the inverse to the list
i                                   #return the inverse from the function
}
#Code to test the functions
#mdat <- matrix(c(100,200,300,400), nrow = 2, ncol = 2, byrow = TRUE)  Create a test matrix
#x<-makeCacheMatrix(mdat)                                              Assign the special matrix to x
#cacheSolve(x)                                                         Find the inverse
#y<-cacheSolve(x)                                                      Make sure the "getting cached data message" works
#mdat%*%y                                                              Verify you get the identity matrix back
mdat <- matrix(c(100,200,300,400), nrow = 2, ncol = 2, byrow = TRUE)
x<-makeCacheMatrix(mdat)
cacheSolve(x)
y<-cacheSolve(x)
mdat%*%y
